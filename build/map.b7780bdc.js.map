{"version":3,"sources":["js/map.js"],"names":["getSelectedOptionsText","option0","document","getElementById","getAttribute","option1","textContent","findMatchingStationsnew","selectedOptions","jsonData","matchingStations","forEach","station","push","createMarkers","coordinatesArray","map","coordinate","lat","lng","station_name","ride_count","L","marker","addTo","bindPopup","concat","geojsonDataCache","displayCommunityAreaBorder","leafletMap","location_type_selection","location_selection","toUpperCase","displayBorderWithGeoJSON","fetchGeoJSONData","then","geojsonData","catch","error","console","selectedFeature","features","feature","properties","community","pri_neigh","name","ward","geojsonLayer","geoJSON","style","color","weight","fillColor","fillOpacity","fitBounds","getBounds","log","clearMarkersAndBorders","eachLayer","layer","Marker","GeoJSON","removeLayer","updateTitle","selectedOption0","selectedOption1","trim","titleElement","querySelector","newTitle"],"mappings":";AACA,SAASA,IAaL,MAXwB,CAIpBC,QAASC,SAASC,eAAe,mBAAmBC,aAAa,SAGjEC,QAASH,SAASC,eAAe,mBAAmBG,aAQ5D,SAASC,EAAwBC,EAAiBC,GAE9C,IAAMC,EAAmB,GAYzB,OAVAD,EAASE,QAAQ,SAAAC,GAGTA,EAAQJ,EAAgBP,WAAaO,EAAgBH,SAEvDK,EAAiBG,KAAKD,KAKrBF,EAIX,SAASI,EAAcC,EAAkBC,GAErCD,EAAiBJ,QAAQ,SAAAM,GAEvB,IAAQC,EAAuCD,EAAvCC,IAAKC,EAAkCF,EAAlCE,IAAKC,EAA6BH,EAA7BG,aAAcC,EAAeJ,EAAfI,WAEjBC,EAAEC,OAAO,CAACL,EAAKC,IAAMK,MAAMR,GAEnCS,UAASC,MAAAA,OACRN,EAAYM,wBAAAA,OAAuBL,MAMjD,IAAIM,EAAmB,GAGvB,SAASC,EAA2BpB,EAAiBqB,GAEjD,IAAIC,EAA0BtB,EAAgBP,QAC1C8B,EAAqBvB,EAAgBH,QAGT,mBAA5ByB,GAA4E,SAA5BA,IAEhDC,EAAqBA,EAAmBC,eAIvCL,EAAiBG,GAalBG,EAAyBH,EAAyBC,EAAoBF,EAAYF,EAAiBG,IAXnGI,iBAAiBJ,GACZK,KAAK,SAAUC,GAEZH,EAAyBH,EAAyBC,EAAoBF,EAAYO,KAErFC,MAAM,SAAUC,GAEbC,QAAQD,MAAM,gCAAkCA,KAShE,SAASL,EAAyBH,EAAyBC,EAAoBF,EAAYO,GAEvF,GAAKA,EAAL,CAMA,IAAII,EAAkB,KAgBtB,GAbAJ,EAAYK,SAAS9B,QAAQ,SAAU+B,IAEF,mBAA5BZ,GAAgDY,EAAQC,WAAWC,YAAcb,GACrD,iBAA5BD,GAA8CY,EAAQC,WAAWE,YAAcd,GACnD,SAA5BD,GAAsCY,EAAQC,WAAWG,OAASf,GACtC,SAA5BD,GAAsCY,EAAQC,WAAWI,OAAShB,KAGnES,EAAkBE,KAKtBF,EAAiB,CAEjB,IAMMQ,EAAe1B,EAAE2B,QAAQT,EAAiB,CAC5CU,MAPgB,CAChBC,MAAO,OACPC,OAAQ,EACRC,UAAW,YACXC,YAAa,MAKjBN,EAAaxB,MAAMK,GAGnBA,EAAW0B,UAAUP,EAAaQ,kBAGlCjB,QAAQkB,IAAI,mBAAqB1B,EAAqB,qCAtCtDQ,QAAQD,MAAM,sCA2CtB,SAASoB,EAAuB1C,GAE5BA,EAAI2C,UAAU,SAAAC,IAENA,aAAiBtC,EAAEuC,QAAUD,aAAiBtC,EAAEwC,UAEhD9C,EAAI+C,YAAYH,KAK5B,SAASI,IAEL,IAAMC,EAAkB/D,SAASC,eAAe,mBAAmBG,YAC7D4D,EAAkBhE,SAASC,eAAe,mBAAmBG,YAGnE,GAA+B,KAA3B4D,EAAgBC,OAAe,CAE/B,IAAMC,EAAelE,SAASmE,cAAc,eACxCC,EAAQ5C,qBAAAA,OAAwBuC,EAAoC,uBACxEG,EAAa9D,YAAcgE,MACxB,CAEH,IAAIA,EAAQ5C,qBAAAA,OAAwBuC,EAAevC,MAAAA,OAAKwC,GAGnChE,SAASmE,cAAc,eAC/B/D,YAAcgE","file":"map.b7780bdc.js","sourceRoot":"..","sourcesContent":["// This function finds the selections of location type and location\nfunction getSelectedOptionsText() {\n    // It creates a box to hold the choices.\n    const selectedOptions = {\n        // Inside the box, there are two things to know:\n\n        // 1. Find the value attribute of the locatoin type selection in index.html\n        option0: document.getElementById(\"selectedOption0\").getAttribute(\"value\"),\n\n        // 2. Find the selection of the location dropdown\n        option1: document.getElementById(\"selectedOption1\").textContent,\n    };\n\n    // After looking at these things, we put the choices in our box.\n    return selectedOptions;\n}\n\n// This function helps find things that match the location type and locatoin selections.\nfunction findMatchingStationsnew(selectedOptions, jsonData) {\n    // It has a list to collect things that match the choices.\n    const matchingStations = [];\n    // It looks at each thing in a big list of information.\n    jsonData.forEach(station => {\n\n        // If a the location type and locaton match with the jsondata,\n        if (station[selectedOptions.option0] === selectedOptions.option1) {\n          // add that thing to our list.\n          matchingStations.push(station);\n        }\n    });  \n\n    // After looking at all the things, give the list to the computer.\n    return matchingStations;\n}\n\n// This function helps create the markers on a map\nfunction createMarkers(coordinatesArray, map) {\n    // It looks at each set of coordinates in a list.\n    coordinatesArray.forEach(coordinate => {\n      // It takes the information about that place.\n      const { lat, lng, station_name, ride_count } = coordinate;\n      // It puts a marker on that place on the map.\n      const marker = L.marker([lat, lng]).addTo(map);\n      // It writes the ride count on the marker popup.\n      marker.bindPopup(\n        `<b>${station_name}</b><br>Ride Count: ${ride_count}`\n      );\n    });\n}\n\n// This function helps create a border on the map.\nlet geojsonDataCache = {}; // Cache for storing fetched GeoJSON data\n\n// This function helps create a border on the map.\nfunction displayCommunityAreaBorder(selectedOptions, leafletMap) {\n    // It looks at a name.\n    let location_type_selection = selectedOptions.option0;\n    let location_selection = selectedOptions.option1;\n\n    // It makes the name uppercase.\n    if (location_type_selection === 'community_area' || location_type_selection === 'city') {\n        // If location_type_selection is 'community_area', convert the name to uppercase\n        location_selection = location_selection.toUpperCase();\n    }\n\n    // Check if GeoJSON data is already cached\n    if (!geojsonDataCache[location_type_selection]) {\n        // If not cached, fetch and cache the GeoJSON data\n        fetchGeoJSONData(location_type_selection)\n            .then(function (geojsonData) {\n                // After fetching, display the border on the map\n                displayBorderWithGeoJSON(location_type_selection, location_selection, leafletMap, geojsonData);\n            })\n            .catch(function (error) {\n                // Handle any errors here\n                console.error(\"Error fetching GeoJSON data: \" + error);\n            });\n    } else {\n        // If already cached, display the border using cached data\n        displayBorderWithGeoJSON(location_type_selection, location_selection, leafletMap, geojsonDataCache[location_type_selection]);\n    }\n}\n\n// This function displays the border on the map.\nfunction displayBorderWithGeoJSON(location_type_selection, location_selection, leafletMap, geojsonData) {\n    // Check if geojsonData is null or undefined\n    if (!geojsonData) {\n        console.error(\"GeoJSON data is null or undefined.\");\n        return;\n    }\n\n    // declaring a variable and setting to null\n    let selectedFeature = null;\n\n    // Iterate through the features in geojsonData to find a match\n    geojsonData.features.forEach(function (feature) {\n        if (\n            (location_type_selection === 'community_area' && feature.properties.community === location_selection) ||\n            (location_type_selection === 'neighborhood' && feature.properties.pri_neigh === location_selection) ||\n            (location_type_selection === 'city' && feature.properties.name === location_selection) ||\n            (location_type_selection === 'ward' && feature.properties.ward === location_selection)\n            // Add more conditions as needed\n        ) {\n            selectedFeature = feature;\n        }\n    });\n\n    // If it finds the match,\n    if (selectedFeature) {\n        // It draws a blue border around it.\n        const customStyle = {\n            color: 'blue',       // Border color\n            weight: 2,          // Border weight\n            fillColor: 'lightblue',  // Fill color\n            fillOpacity: 0.5    // Fill opacity\n        };\n        const geojsonLayer = L.geoJSON(selectedFeature, {\n            style: customStyle\n        });\n        geojsonLayer.addTo(leafletMap);\n\n        // It makes the map move to the center of the border\n        leafletMap.fitBounds(geojsonLayer.getBounds());\n    } else {\n        // If it can't find a match, it says there's a problem.\n        console.log(\"Community area '\" + location_selection + \"' not found in GeoJSON data.\");\n    }\n}\n\n// This function clears markers and boarders on the map.\nfunction clearMarkersAndBorders(map) {\n    // It goes through everything on the map.\n    map.eachLayer(layer => {\n        // If it's a marker or a line (border),\n        if (layer instanceof L.Marker || layer instanceof L.GeoJSON) {\n            // It removes it from the map.\n            map.removeLayer(layer);\n        }\n    });\n}\n\nfunction updateTitle() {\n    // Get the text content of selectedOption0 and selectedOption1\n    const selectedOption0 = document.getElementById(\"selectedOption0\").textContent;\n    const selectedOption1 = document.getElementById(\"selectedOption1\").textContent;\n\n    // Check if selectedOption1 is blank\n    if (selectedOption1.trim() === \"\") {\n        // If it's blank, show a message to make a selection\n        const titleElement = document.querySelector(\".map__title\");\n        let newTitle = `Divvy Station Map ${selectedOption0}: Select a Location`;\n        titleElement.textContent = newTitle;\n    } else {\n        // Combine the text content to form the new title\n        let newTitle = `Divvy Station Map ${selectedOption0}: ${selectedOption1}`;\n\n        // Update the title element with the new title\n        const titleElement = document.querySelector(\".map__title\");\n        titleElement.textContent = newTitle;\n    }\n}\n\n  \n\n"]}